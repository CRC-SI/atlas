define([
  'atlas/util/Class',
  'atlas/util/DeveloperError'
], function (Class, DeveloperError) {

  /**
   * Define the ItemStore constructor as type atlas.core.ItemStore
   * @typedef atlas.core.ItemStore
   * @ignore
   */
  var ItemStore;

  /**
   * @classdesc The ItemStore is a class to encapsulate storing and retrieving arbitrary
   * objects using unique IDs. The unique IDs need to be generated by the objects being
   * stored.
   * @param {String} id - The name of the getter function for the objects ID. Defaults
   * to <code>getId</code>.
   * @class atlas.core.ItemStore
   */
  ItemStore = Class.extend( /** @lends atlas.core.FooStore# */ {

    /**
     * The getter function for the ID of the stored objects.
     * @type {String}
     */
    _getterName: null,

    /**
     * Count of items in the store.
     * @type {number}
     */
    _count: 0,

    /**
     * The objects stored in the ItemStore.
     * @type {Object.<String, Object>}
     * @private
     */
    _items: null,

    _init: function (getter) {
      this.purge();
      this._getterName = getter || 'getId';
    },

    // -------------------------------------------------
    // GETTERS AND SETTERS
    // -------------------------------------------------

    /**
     * @returns {number} The number of items in the store.
     */
    getCount: function () {
      return this._count;
    },

    // -------------------------------------------------
    // ADDING AND REMOVING
    // -------------------------------------------------

    /**
     * Add an object to the store.
     * @param {Object} obj - The object to add.
     */
    add: function (obj) {
      if (!obj[this._getterName]) {
        throw new DeveloperError('Tried to add object without an ID getter to the store.');
      }
      var id = obj[this._getterName]();
      this._items[id] = obj;
      this._count++;
    },

    /**
     * Adds an array of objects to the store.
     * @param {Array.<Object>} objs - The array of objects to add.
     */
    addArray: function (objs) {
      objs.forEach(function (obj) {
        this.add(obj);
      }, this);
    },

    /**
     * Remove an object from the store.
     * @param {String} id - The ID of the object to remove.
     * @returns {Object} The removed object.
     */
    remove: function (id) {
      var obj = this._items[id];
      delete this._items[id];
      this._count--;
      return obj;
    },

    /**
     * @param {String} id - The ID of the object to retrieve.
     * @returns {Object?} The object with the given ID.
     */
    get: function (id) {
      return this._items[id];
    },

    /**
     * Removes all items from the store.
     */
    purge: function () {
      this._items = {};
    },

    // -------------------------------------------------
    // FOO MODIFICATION
    // -------------------------------------------------

    /**
     * Maps a function to every foo in the store. The function is assumed to be a
     * property of every object in the store.
     * @param {String} functionName - Name of the function to apply.
     * @param {Array} [args] - An array of arguments for the function.
     */
    map: function (functionName, args) {
      Object.keys(this._items).map(function (id) {
        var foo = this.get(id);
        return foo[functionName].apply(foo, args);
      }, this);
    },

    /**
     * Applies a given function to every foo in the store. The given function is called once for
     * every object in the store, with the object being the only argument.
     * @param {Function.<Object>} f - The function to call.
     * @param {Object} [scope] - The object that <code>this</code> will refer to.
     */
    forEach: function (f, scope) {
      scope = scope || this;
      Object.keys(this._items).forEach(function (id) {
        var foo = this.get(id);
        f.bind(scope)(foo)
      }, this);
    }

  });

  return ItemStore;
});
